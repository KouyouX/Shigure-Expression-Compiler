package org.owari.shigure.codegen

import org.owari.shigure.SExprImpl

import org.objectweb.asm.ClassWriter
import org.objectweb.asm.Opcodes
import org.owari.shigure.Shigure
import org.owari.shigure.ast.*
import java.util.concurrent.atomic.AtomicInteger

private object SExprClassLoader : ClassLoader(Shigure.javaClass.classLoader) {
    fun define(name: String, code: ByteArray): Class<*> = defineClass(name, code, 0, code.size)
}

/**
 * @author Mochizuki Haruka
 * codeGenerator 的默认实现.
 */
class SCodeGenerator(val ast: SRootNode) {
    val result by lazy(this::generate)

    companion object {
        @JvmStatic
        private val id = AtomicInteger(0)
    }
    
    private val clazzId = id.getAndIncrement()
    private val clazzFileName = "org/owari/shigure/generated/SExprImpl\$$clazzId"
    private val clazzName = "org.owari.shigure.generated.SExprImpl\$$clazzId"
    private val cw = ClassWriter(ClassWriter.COMPUTE_FRAMES or ClassWriter.COMPUTE_MAXS)

    init {
        cw.visit(
            52,
            Opcodes.ACC_PUBLIC or Opcodes.ACC_SUPER or Opcodes.ACC_FINAL,
            clazzFileName,
            null,
            "org/owari/shigure/SExprImpl",
            null
        )
        cw.visitSource("<generated by ShigureExprCompiler>", null)
        val con = cw.visitMethod(Opcodes.ACC_PUBLIC, "<init>", "()V", null, null)
        con.visitCode()
        con.visitIntInsn(Opcodes.ALOAD, 0)
        con.visitMethodInsn(Opcodes.INVOKESPECIAL, "org/owari/shigure/SExprImpl", "<init>", "()V", false)
        con.visitInsn(Opcodes.RETURN)
        con.visitMaxs(0, 0)
        con.visitEnd()
    }
    private val mw =
        cw.visitMethod(Opcodes.ACC_PUBLIC or Opcodes.ACC_FINAL, "eval", "(Lorg/owari/shigure/SContext;)D", null, null)

    // local[0] = this, local[1] = SContext, local[i..j] = variables, local[j+1..k] = functions
    private val exprVarOffset = 2
    private val exprFnOffset = exprVarOffset + ast.usedVars.size * 2
    private inline fun varAddress(i: Int) = exprVarOffset + i * 2
    private inline fun varAddress(s: String) = varAddress(ast.usedVars.indexOf(s))
    private inline fun fnAddress(i: Int) = exprFnOffset + i
    private inline fun fnAddress(s: String) = fnAddress(ast.usedFns.indexOf(s))

    private inline fun generate(): SExprImpl {
        emitPrologue()
        emit(ast)
        emitEpilogue()
        return assembly()
    }

    private inline fun emitPrologue() {
        mw.visitCode()
        mw.visitVarInsn(Opcodes.ALOAD, 1) // load SContext into stack
        ast.usedVars.forEach {
            mw.visitInsn(Opcodes.DUP) // duplicate SContext
            mw.visitLdcInsn(it) // load variable name into stack
            mw.visitMethodInsn(
                Opcodes.INVOKEVIRTUAL,
                "org/owari/shigure/SContext",
                "getVariable",
                "(Ljava/lang/String;)D",
                false
            ) // get variable from SContext
            mw.visitVarInsn(Opcodes.DSTORE, varAddress(it)) // store variable into local
        }
        ast.usedFns.forEach {
            mw.visitInsn(Opcodes.DUP) // duplicate SContext
            mw.visitLdcInsn(it) // load function name into stack
            mw.visitMethodInsn(
                Opcodes.INVOKEVIRTUAL,
                "org/owari/shigure/SContext",
                "getFunction",
                "(Ljava/lang/String;)Lorg/owari/shigure/SFunction;",
                false
            ) // get function from SContext
            mw.visitVarInsn(Opcodes.ASTORE, fnAddress(it)) // store function into local
        }
        mw.visitInsn(Opcodes.POP) // pop SContext
    }

    private inline fun emitEpilogue() {
        mw.visitInsn(Opcodes.DRETURN)
        mw.visitMaxs(0, 0)
        mw.visitEnd()
    }

    private fun emit(e: SExprNode) {
        when (e) {
            is SRootNode -> emit(e.expr)
            is SUnaryExprNode -> emit(e)
            is SBinaryExprNode -> emit(e)
            is SVarAccessNode -> emit(e)
            is SConstNumNode -> emit(e)
            is SFnCallNode -> emit(e)
        }
    }

    private fun emit(e: SUnaryExprNode) {
        when (e.op) {
            SExprOperator.ADD -> {
                emit(e.value) // 对 double 取一元加没有实际意义
            }

            SExprOperator.SUB -> {
                emit(e.value)
                mw.visitInsn(Opcodes.DNEG)
            }
        }
    }

    private fun emit(e: SBinaryExprNode) {
        when (e.op) {
            SExprOperator.ADD -> {
                emit(e.lhs)
                emit(e.rhs)
                mw.visitInsn(Opcodes.DADD)
            }

            SExprOperator.SUB -> {
                emit(e.lhs)
                emit(e.rhs)
                mw.visitInsn(Opcodes.DSUB)
            }

            SExprOperator.MUL -> {
                emit(e.lhs)
                emit(e.rhs)
                mw.visitInsn(Opcodes.DMUL)
            }

            SExprOperator.DIV -> {
                emit(e.lhs)
                emit(e.rhs)
                mw.visitInsn(Opcodes.DDIV)
            }

            SExprOperator.MOD -> {
                emit(e.lhs)
                emit(e.rhs)
                mw.visitInsn(Opcodes.DREM)
            }
            SExprOperator.POW -> {
                emit(e.lhs) // base
                emit(e.rhs) // exponent
                mw.visitMethodInsn(Opcodes.INVOKESTATIC, "java/lang/Math", "pow", "(DD)D", false)
            }

            SExprOperator.DIVFLOOR -> {
                emit(e.lhs)
                emit(e.lhs)
                mw.visitInsn(Opcodes.DDIV)
                mw.visitInsn(Opcodes.D2L)
                mw.visitInsn(Opcodes.L2D)
            }
        }
    }

    private fun emit(e: SVarAccessNode) {
        val index = varAddress(e.name)
        assert(index != -1)
        mw.visitVarInsn(Opcodes.DLOAD, index)
    }

    private fun emit(e: SConstNumNode) {
        mw.visitLdcInsn(e.value)
    }

    private fun emit(e: SFnCallNode) {
        mw.visitIntInsn(Opcodes.BIPUSH, e.args.size)
        mw.visitIntInsn(Opcodes.NEWARRAY, Opcodes.T_DOUBLE)
        e.args.forEachIndexed { i, it ->
            mw.visitInsn(Opcodes.DUP)
            mw.visitIntInsn(Opcodes.BIPUSH, i)
            emit(it)
            mw.visitInsn(Opcodes.DASTORE)
        }
        mw.visitMethodInsn(
            Opcodes.INVOKEINTERFACE,
            "org/owari/shigure/runtime/ArithmeticFunction",
            "call",
            "([D)D",
            true
        )
    }

    private fun assembly(): SExprImpl {
        val ba = cw.toByteArray()
        val clazz = SExprClassLoader.define(clazzName, ba)
        assert(SExprImpl::class.java.isAssignableFrom(clazz))
        return clazz.getDeclaredConstructor().newInstance() as SExprImpl
    }
}
