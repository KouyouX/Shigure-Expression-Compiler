package org.owari.shigure.impl

import org.objectweb.asm.*

import org.owari.shigure.Shigure
import java.util.concurrent.atomic.AtomicLong

/**
 * @author Mochizuki Haruka
 * codeGenerator 的默认实现.
 */
class CodeGenerator(
    private val ast: SyntaxTree,
    private val assembler: Assembler
) {
    val result by lazy(this::generate)

    companion object {
        @JvmStatic
        private val id = AtomicLong(0)
    }
    
    private val clazzId = id.getAndIncrement()
    private val clazzName = "org.owari.shigure.generated.ExpressionImpl\$$clazzId"
    private val clazzFileName = clazzName.replace('.', '/')
    private val cw = ClassWriter(ClassWriter.COMPUTE_FRAMES or ClassWriter.COMPUTE_MAXS)

    init {
        cw.visit(
            52,
            Opcodes.ACC_PUBLIC or Opcodes.ACC_SUPER or Opcodes.ACC_FINAL,
            clazzFileName,
            null,
            "org/owari/shigure/SExprImpl",
            null
        )
        cw.visitSource("<generated by ShigureExprCompiler>", null)
        val con = cw.visitMethod(Opcodes.ACC_PUBLIC, "<init>", "()V", null, null)
        con.visitCode()
        con.visitIntInsn(Opcodes.ALOAD, 0)
        con.visitMethodInsn(Opcodes.INVOKESPECIAL, "org/owari/shigure/SExprImpl", "<init>", "()V", false)
        con.visitInsn(Opcodes.RETURN)
        con.visitMaxs(0, 0)
        con.visitEnd()
    }
    private val mw =
        cw.visitMethod(Opcodes.ACC_PUBLIC or Opcodes.ACC_FINAL, "eval", "(Lorg/owari/shigure/SContext;)D", null, null)

    // local[0] = this, local[1] = Context object, local[i..j] = variables
    private val varSize = 2
    private var currentOffset = 2
    private val varMap = hashMapOf<String, Int>()
    private fun newVar(name: String): Int {
        varMap[name] = currentOffset
        return currentOffset.also { currentOffset += varSize }
    }
    private fun address(name: String): Int = varMap[name] ?: newVar(name)

    fun generate(): ByteArray {
        emitPrologue()
        emit(ast)
        emitEpilogue()
        return cw.toByteArray()
    }

    private inline fun emitPrologue() {
        mw.visitCode()
        mw.visitVarInsn(Opcodes.ALOAD, 1) // load SContext into stack
        ast.usedVars.forEach {
            mw.visitInsn(Opcodes.DUP) // duplicate SContext
            mw.visitLdcInsn(it) // load variable name into stack
            mw.visitMethodInsn(
                Opcodes.INVOKEVIRTUAL,
                "org/owari/shigure/SContext",
                "getVar",
                "(Ljava/lang/String;)D",
                false
            ) // get variable from SContext
            mw.visitVarInsn(Opcodes.DSTORE, varAddress(it)) // store variable into local
        }
        ast.usedFns.forEach {
            mw.visitInsn(Opcodes.DUP) // duplicate SContext
            mw.visitLdcInsn(it) // load function name into stack
            mw.visitMethodInsn(
                Opcodes.INVOKEVIRTUAL,
                "org/owari/shigure/SContext",
                "getFn",
                "(Ljava/lang/String;)Lorg/owari/shigure/runtime/ArithmeticFunction;",
                false
            ) // get function from SContext
            mw.visitVarInsn(Opcodes.ASTORE, fnAddress(it)) // store function into local
        }
        mw.visitInsn(Opcodes.POP) // pop SContext
    }

    private inline fun emitEpilogue() {
        mw.visitInsn(Opcodes.DRETURN)
        mw.visitMaxs(0, 0)
        mw.visitEnd()
    }

    private fun emit(e: SExprNode) {
        when (e) {
            is SRootNode -> emit(e.expr)
            is SUnaryExprNode -> emit(e)
            is SBinaryExprNode -> emit(e)
            is SVarAccessNode -> emit(e)
            is SConstNumNode -> emit(e)
            is SFnCallNode -> emit(e)
        }
    }

    private fun emit(e: SUnaryExprNode) {
        when (e.op) {
            SExprOperator.ADD -> {
                emit(e.value) // 对 double 取一元加没有实际意义
            }

            SExprOperator.SUB -> {
                emit(e.value)
                mw.visitInsn(Opcodes.DNEG)
            }
        }
    }

    private fun emit(e: SBinaryExprNode) {
        when (e.op) {
            SExprOperator.ADD -> {
                emit(e.lhs)
                emit(e.rhs)
                mw.visitInsn(Opcodes.DADD)
            }

            SExprOperator.SUB -> {
                emit(e.lhs)
                emit(e.rhs)
                mw.visitInsn(Opcodes.DSUB)
            }

            SExprOperator.MUL -> {
                emit(e.lhs)
                emit(e.rhs)
                mw.visitInsn(Opcodes.DMUL)
            }

            SExprOperator.DIV -> {
                emit(e.lhs)
                emit(e.rhs)
                mw.visitInsn(Opcodes.DDIV)
            }

            SExprOperator.MOD -> {
                emit(e.lhs)
                emit(e.rhs)
                mw.visitInsn(Opcodes.DREM)
            }
            SExprOperator.POW -> {
                emit(e.lhs) // base
                emit(e.rhs) // exponent
                mw.visitMethodInsn(Opcodes.INVOKESTATIC, "java/lang/Math", "pow", "(DD)D", false)
            }

            SExprOperator.FLOORDIV -> {
                emit(e.lhs)
                emit(e.lhs)
                mw.visitInsn(Opcodes.DDIV)
                mw.visitInsn(Opcodes.D2L)
                mw.visitInsn(Opcodes.L2D)
            }
        }
    }

    private fun emit(e: SVarAccessNode) {
        mw.visitVarInsn(Opcodes.DLOAD, address(e.name))
    }

    private fun emit(e: SConstNumNode) {
        mw.visitLdcInsn(e.value.toDouble())
    }

    private fun emit(e: SFnCallNode) {
        mw.visitVarInsn(Opcodes.ALOAD, fnAddress(e.name))
        mw.visitIntInsn(Opcodes.BIPUSH, e.args.size)
        mw.visitIntInsn(Opcodes.NEWARRAY, Opcodes.T_DOUBLE)
        e.args.forEachIndexed { i, it ->
            mw.visitInsn(Opcodes.DUP)
            mw.visitIntInsn(Opcodes.BIPUSH, i)
            emit(it)
            mw.visitInsn(Opcodes.DASTORE)
        }
        mw.visitMethodInsn(
            Opcodes.INVOKEINTERFACE,
            "org/owari/shigure/runtime/ArithmeticFunction",
            "call",
            "([D)D",
            true
        )
    }
}
